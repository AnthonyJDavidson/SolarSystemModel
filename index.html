<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Solar System</title>
	</head>

	<body>
		<!-- This id will contain the threeJs scene !-->
		<div id="sceneContainer"></div>
		<script src="build/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script> /* This is my personal work ( the above are the relevant libraries) */

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var sceneContainer, stats;
			var camera, controls, scene, renderer, projector;
			var planets = [];

			init();
			render();

			function init() {

				projector = new THREE.Projector();
				// PerspectiveCamera( fov, aspect, near, far )
				// Foz = 60, aspect = screen aspect. near = 1 , far - 80k (largest radius is Neptune at 30k and diameter will be 60k)
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 200000 );
				camera.position = new THREE.Vector3( 0, 0, 30001);

				//Declare camera Controls (three OrbitControls)
				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );

				scene = new THREE.Scene();



				/*
				__________.__                        __          
				\______   \  | _____    ____   _____/  |_  ______
				 |     ___/  | \__  \  /    \_/ __ \   __\/  ___/
				 |    |   |  |__/ __ \|   |  \  ___/|  |  \___ \ 
				 |____|   |____(____  /___|  /\___  >__| /____  >
				                    \/     \/     \/          \/ 
				*/
				// sphereGeometry arguments = (radius,segmentsWidth,segmentsHeight)
				//segments width and heighth refer to how perfect the circle is (higher value = more rendering power required)

				//This is not a metrically accurate sun as to do so the solar system would be mostly empty space (as in real world)
				var sunGeo = new THREE.SphereGeometry( 100, 24,24 );
				//Radius in relation to earth's radius = 10
				var mercuryGeo = new THREE.SphereGeometry( 3.8, 24, 24 );
				var venusGeo = new THREE.SphereGeometry( 9.5, 24, 24 );
				var earthGeo = new THREE.SphereGeometry( 10, 24, 24 );
				var marsGeo = new THREE.SphereGeometry( 5.3, 24, 24 );
				var jupiterGeo = new THREE.SphereGeometry( 110, 24, 24 );
				var saturnGeo = new THREE.SphereGeometry( 94, 24, 24 );
				var uranusGeo = new THREE.SphereGeometry( 44, 24, 24 );
				var neptuneGeo = new THREE.SphereGeometry( 39, 24, 24 );

				var sunMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/sunmap')});
				var mercuryMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/mercurymap.jpeg')});
				var venusMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/venusmap.jpeg')});
				var earthMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/earthmap1k.jpeg')});
				var marsMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/mars_1k_color.jpeg')});
				var jupiterMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/jupitermap.jpeg')});
				var saturnMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/saturnmap.jpeg')});
				var uranusMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/uranusmap.jpeg')});
				var neptuneMaterial = new THREE.MeshPhongMaterial({map: THREE.ImageUtils.loadTexture('images/neptunemap.jpeg')});
				/*
				var sunMaterial = new THREE.MeshNormalMaterial();
				var mercuryMaterial= new THREE.MeshLambertMaterial( { color: 0xDB1A1A} ) ;
				var venusMaterial = new THREE.MeshLambertMaterial( { color: 0x1A4BDB} ) ;
				var earthMaterial = new THREE.MeshNormalMaterial();
				var marsMaterial = new THREE.MeshBasicMaterial( { color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending } ) ;
				var jupiterMaterial = new THREE.MeshNormalMaterial();
				var uranusMaterial = new THREE.MeshNormalMaterial();
				//materials.push( new THREE.MeshBasicMaterial( { color: 0xff0000, blending: THREE.SubtractiveBlending } ) );

				var saturnMaterial= new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.SmoothShading } ) ;
				var neptuneMaterial = new THREE.MeshPhongMaterial( { ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, transparent: true } ) ;
				*/


				var theSun = new THREE.Mesh(sunGeo, sunMaterial);
				theSun.position = new THREE.Vector3( 0, 0, 0 );
				planets.push(theSun);
				var mercury = new THREE.Mesh(mercuryGeo, mercuryMaterial);
				mercury.position = new THREE.Vector3( 390, 0, 0 );
				planets.push(mercury);
				var venus = new THREE.Mesh(venusGeo, venusMaterial);
				venus.position = new THREE.Vector3( 720, 0, 0 );
				planets.push(venus);
				var earth = new THREE.Mesh(earthGeo, earthMaterial);
				earth.position = new THREE.Vector3( 1000, 0, 0 );
				planets.push(earth);
				var mars = new THREE.Mesh(marsGeo, marsMaterial);
				mars.position = new THREE.Vector3( 1500, 0, 0 );
				planets.push(mars);
				var jupiter = new THREE.Mesh(jupiterGeo, jupiterMaterial);
				jupiter.position = new THREE.Vector3( 5200, 0, 0 );
				planets.push(jupiter);
				var saturn = new THREE.Mesh(saturnGeo, saturnMaterial);
				saturn.position = new THREE.Vector3( 9500, 0, 0 );
				planets.push(saturn);
				var uranus = new THREE.Mesh(uranusGeo, uranusMaterial);
				uranus.position = new THREE.Vector3( 19000, 0, 0 );
				planets.push(uranus);
				var neptune = new THREE.Mesh(neptuneGeo, neptuneMaterial);
				neptune.position = new THREE.Vector3( 30000, 0, 0 );
				planets.push(neptune);


				//Names to be stored for later use
				theSun.nameOfPlanet = 'theSun';
				mercury.nameOfPlanet = 'mercury';
				venus.nameOfPlanet = 'venus';
				earth.nameOfPlanet = 'earth';
				mars.nameOfPlanet = 'mars';
				jupiter.nameOfPlanet = 'jupiter';
				saturn.nameOfPlanet = 'saturn';
				uranus.nameOfPlanet = 'uranus';
				neptune.nameOfPlanet = 'neptune';


				//Add planets to the scene
				scene.add(theSun);
				scene.add( mercury );
				scene.add( venus );
				scene.add( earth );
				scene.add( mars );
				scene.add( jupiter );
				scene.add( saturn );
				scene.add( uranus );
				scene.add( neptune );

				/*
				________       ___.   .__  __          
				\_____  \______\_ |__ |__|/  |_  ______
				 /   |   \_  __ \ __ \|  \   __\/  ___/
				/    |    \  | \/ \_\ \  ||  |  \___ \ 
				\_______  /__|  |___  /__||__| /____  >
   					    \/          \/              \/ 
   				*/

				//Orbit lines to show orbit
				var createOrbitLine = function(radius,color){
					var circleRadius = radius;
					var circleShape = new THREE.Shape();
					circleShape.moveTo( 0, circleRadius );
					circleShape.quadraticCurveTo( circleRadius, circleRadius, circleRadius, 0 );
					circleShape.quadraticCurveTo( circleRadius, -circleRadius, 0, -circleRadius );
					circleShape.quadraticCurveTo( -circleRadius, -circleRadius, -circleRadius, 0 );
					circleShape.quadraticCurveTo( -circleRadius, circleRadius, 0, circleRadius );
					var points = circleShape.createPointsGeometry();
					var spacedPoints = circleShape.createSpacedPointsGeometry( 200 );
					var line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: color, linewidth: 0.01} ) );
					line.position.set(0,0,0);
					scene.add(line);
				};

				createOrbitLine(390, 0xFABF41);
				createOrbitLine(720, 0xFA8E41);
				createOrbitLine(1000, 0x3BA7FF);
				createOrbitLine(1500, 0xFF5533);
				createOrbitLine(5200, 0xFFC76E);
				createOrbitLine(9500, 0xFFE2B3);
				createOrbitLine(19000, 0xCCFEFF);
				createOrbitLine(30000, 0x00E1FF);

/*				.____    .__       .__     __          
				|    |   |__| ____ |  |___/  |_  ______
				|    |   |  |/ ___\|  |  \   __\/  ___/
				|    |___|  / /_/  >   Y  \  |  \___ \ 
				|_______ \__\___  /|___|  /__| /____  >
				        \/ /_____/      \/          \/ */

				// lights
				
				var light = new THREE.SpotLight( 0xff0000 );
				light.position.set( 0, 0, 0 );
				light.target.position.set( 30000, 0, 0 );
				scene.add(light);

				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );









				// renderer for the scene (using WebGL)
				// can be set to true depending on machine
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				// size of scene is entrie screen size
				renderer.setSize( window.innerWidth, window.innerHeight );
				sceneContainer = document.getElementById( 'sceneContainer' );
				sceneContainer.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
				sceneContainer.addEventListener( 'mousedown', onMouseDown, false );

			}
			//Make the scenesize dynamic
			function onWindowResize() {
				//renderer must always be screen size
				renderer.setSize( window.innerWidth, window.innerHeight );
				//Camera Aspect is also the same
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix(); //projections also must be updated
				render();//Scene must be re rendered when resizing is done
			}

			//render the scene
			function render() {
				renderer.render( scene, camera ); //Scene and camera
			}

			function onMouseDown( event ) {
				
				//here I am creating a raycaster currently for myself to click on objects and get their values
				// future work may include giving a pop up with basic information about this planet and links to more information
				event.preventDefault();
				//creating a vector that essentially points out of the mouse to the scene
				vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1, 1 );
				projector.unprojectVector( vector, camera );
				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				//Store all objects intersected by the ray
				var intersects = raycaster.intersectObjects( planets );
				if(intersects.length >0){
					console.log(intersects);
				}
			}


		</script>

	</body>
</html>
